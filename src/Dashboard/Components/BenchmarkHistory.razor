@inject IJSRuntime JS

<div class="benchmark-chart-container col" id="@(Id)">
    <canvas class="benchmark-chart" id="@(CanvasId)" />
</div>

@code {
    /// <summary>
    /// Gets the benchmark name.
    /// </summary>
    [Parameter]
    public required string Name { get; init; }

    /// <summary>
    /// Gets the name of the associated benchmark suite.
    /// </summary>
    [Parameter]
    public required string Suite { get; init; }

    /// <summary>
    /// Gets the benchmark items.
    /// </summary>
    [Parameter]
    public required IList<BenchmarkItem> Items { get; init; }

    private string Id => $"{Suite}-{Name}";

    private string CanvasId => $"{Suite}-{Name}-canvas";

    protected override void OnInitialized()
    {
        NormalizeUnits(Items);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        var options = System.Text.Json.JsonSerializer.Serialize(new
        {
            colors = new
            {
                memory = Options.Value.DataSetColors["Memory"],
                time = Options.Value.DataSetColors["Time"],
            },
            dataset = Items,
            name = Name,
            suiteName = Suite,
        });

        await JS.InvokeVoidAsync("renderChart", [CanvasId, options]);
    }

    private static void NormalizeUnits(IList<BenchmarkItem> items)
    {
        if (items.Count < 1)
        {
            return;
        }

        var minValue = items.Count == 1 ? items[0].Result.Value : double.PositiveInfinity;

        if (items.Count > 1)
        {
            foreach (var item in items)
            {
                minValue = Math.Min(minValue, item.Result.Value);
            }
        }

        double factor = 1e-3;
        double limit = 1_000;

        string[] timeUnits = ["µs", "ms", "s"];

        for (int i = 0; i < timeUnits.Length; i++)
        {
            if (minValue < limit)
            {
                break;
            }

            minValue *= factor;

            for (int j = 0; j < items.Count; j++)
            {
                var item = items[j];

                item.Result.Value *= factor;
                item.Result.Unit = timeUnits[i];

                if (item.Result.Range is not null)
                {
                    item.Result.Range = $"± {double.Parse(item.Result.Range[2..], CultureInfo.InvariantCulture) * factor}";
                }
            }
        }

        if (items.Any((p) => p.Result.BytesAllocated is not null))
        {
            double minBytes = items.Count == 1 ? items[0].Result.BytesAllocated ?? default : double.PositiveInfinity;

            if (items.Count > 1)
            {
                foreach (var item in items)
                {
                    if (item.Result.BytesAllocated is { } value)
                    {
                        minBytes = Math.Min(minBytes, value);
                    }
                }
            }

            string[] memoryUnits = ["KB", "MB"];

            for (int i = 0; i < memoryUnits.Length; i++)
            {
                if (minBytes < limit)
                {
                    break;
                }

                minBytes *= factor;

                for (int j = 0; j < items.Count; j++)
                {
                    var item = items[j];

                    if (item.Result.BytesAllocated is { } value)
                    {
                        item.Result.BytesAllocated *= (long)factor;
                        item.Result.MemoryUnit = memoryUnits[i];
                    }
                }
            }
        }
    }
}
